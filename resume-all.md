# В основном - основное.
# Зачем > синтаксис.

# JSX
- **array.map(...)**. Используем метод map для рендера массивов. **Не забываем про пропс key**. Похожие элементы, возможно, имеет смысл объединить в массив. (Например, для селекта имеет смысл собрать в массив все его опции, а не писать отдельно каждый тег <option>):
```javascipt
// bad
<select>
  <option className="option">Value 1</option>
  <option className="option">Value 2</option>
  <option className="option">Value 3</option>
  <option className="option">Value 4</option>
</select>

// good
const options = [ 'Value1', 'Value2', 'Value3', 'Value4' ];

<select>
  {options.map((option) => <option key={ options } className="option">{ options }</option>)}
</select>
```
- **условный рендер**. Используем для рендера элементов, которые отображаются не всегда, а в зависимости от какого-либо условия (напр. показать меню только если юзер нажал на соответствующую кнопку)
- **подъем состояния**. Т.к. данные в реакте передаются только от родителя детям (т.е. сверху вниз), и если, например, данные понадобились компоненту брату (т.е. компоненту расположенному на одном уровне иерархии), то мы поднимает такие данные выше к их общему родителю и уже от родителя передаем сверху вниз.
```javascipt
const BrotherWithState = () => {
  const [ data ] = useState(0);
  return <span>{data}</span>
}

const Brother = () => {
  return <span>I want your data, BrotherWithState!</span>
}

const App = () => {
// если бы стейт был тут, а не в BrotherWithState то мы могли бы передать его пропсом и в BrotherWithState и Brother

  return (
    <div>
      <BrotherWithState />
      <Brother /> // <= компонент Brother хочет получить доступ к состоянию компонента BrotherWithState. Но мы не можем передать данные соседу или вверх, только вниз. Поэтому мы ПОДНИМАЕТ (переносим) стейт (хук useState) из компонента BrotherWithState в App и раздаем его значение сверху вниз компонентам BrotherWithState и Brother через пропсы
    </div>
);
}


// удаляем стейт из BrotherWithState и переносим его в App
const BrotherWithState = ({ data }) => {
  return <span>{data}</span>
}

const Brother = ({ data }) => {
  return <span>{data}</span>
}

const App = () => {
  // переносим стейт в App и прокидываем как пропсы в BrotherWithState и Brother
  const [ data ] = useState(0);

  return (
    <div>
      <BrotherWithState data={ data } />
      <Brother data={ data } />
    </div>
  );
}
```

# Компоненты
Компонент - функция, возвращающая разметку (html или null). Принимает один единственный аргумент объект, именуемый props.
- Классовый. Обладает стейтом и методами жизненного цикла.
- Функциональный. Реализует стейт и альтернативу методам жизненного цикла через хуки

- Управляемые - получают состояние из вне (через пропсы value и onChage)
- Неуправляемые - имеют свое собственное независимое состояние. Можем получить значение этого состояния используя рефы. Пример неуправляемого компонента:
```javascipt
const Parent = () => {
  // создаем рефу, чтобы получить значения неуправляемого компонента
  const ref = useRef<HTMLInputElement>(null);

  return (
    <div>
      // input – неуправляемый компонент, т.к. не получает через пропсы value. Прокидываем рефу, чтобы получить доступ к инпуту
      <input ref={ref} />
      // через рефу получаем доступ к значению инпута
      <button onClick={() => console.log(ref.current?.value)}>Click</button>
    </div>
  )
}
```

## Стейт или методы жизненного цикла?
- Стейт - переменная. Как и в любом ПО мы хотим иметь переменные. Но обычная переменная не вызывает перерендер компонента (т.е. результат изменения не виден на ui). Поэтому используем концепцию стейта - переменная + функция setState, которая изменяет переменную и при этом вызывает перерендер. **Используем стейт для хранения данных внутри приложения** (Например открыто или закрыто меню, значение инпутов или форм ДО того как эти значения отправлены на бек, полученные данные с бека).
- Методы жизненного цикла - сайд эффекты. **Используются для взаимодействия с внешним миром** (Например, для получения и синхронизации данных с бека, отправки логов, взаимодействия c localStorate, проч взаимодействия с в webApi (напр таймеры))

# Методы жизненного цикла
Компонент проходит несколько фаз - впервые (или после удаления) **монтируется** => **обновляется** => **размонтируется** (удаляется).
На каждом из этих этапов мы можем выполнить какую-нибудь логику через специальные функции колбеки:
- componentDidMount - Срабатывает **после** монтирования компонента. Используется для первоночльного получения данных с бека (например, получения списка товаров в магазине)
- componentDidUpdate - Срабатывает **после** обновления компонента. Используется для обновления (синхронизации) с беком (например, после обновления поискового запроса юзера)
- componenWillUnmount - Срабатывает **перед** размонтированием (удалением) компонента. Используется для очистки ресурсов (например, если мы установили таймер, то его нужно очистить, чтобы освободить ресурсы браузера). Каждый раз когда мы подписываемся на ресурсы (websocket) или занимаем ресурсы (setTimer), устанавливаем соединение, то эти ресурсы надо освобить (отписаться, убрать таймер и тд.) в componenWillUnmount. Если вы выполняете какую-то логику и вы знаете что у нее есть обратное "освобождающее" действие - это почти всегда причина задуматься надо ли применять для этого componenWillUnmount.

- shouldComponentUpdate - Срабатывает **перед** обновлением компонента. Используется для оптимизации: вернув false мы предотвратим рендер компонента. Пример: с бека вам постоянно приходят данные, парсив ответ бека через JSON.parse вы каждый раз получаете новый объект по ссылке (даже если данные не изменились). Если мы хотим, чтобы компонент в такой ситуации рендерился не каждый раз, а только если данные действительно изменились, то мы можем выполнить проверку в shouldComponentUpdate (например, изменился ли хеш или id ответа бекенда) и возвращать false, если данные не изменились и перерендер не нужен.

- static getDerivedStateFromError / componentDidCatch - Используется для создания ErrorBoundary (аналог try / catch для рендера компонента)

# Хуки
## Правила хуков:
- Можно вызывать только в функциональных компонентах и внутри других хуков
- Можно вызывать только верхнеуровнево (нельзя вызывать в циклах, в if, условном рендере и тд.)
- Называем свои хуки с префикса use*

## Основные
- useState - аналог стейта классового компонента. Не забываем про синтаксис колбека когда рассчитываем следующее состояние на основе предыдущего. В отличие от классового у useState:
  - нет ограничения на кол-во стейтов в одном компоненте (можно сделать 2+ стейта)
  - состояние может быть любым типом данных (не только объект)
  - НО если наше состояние объект, то при частичном обновлении такого объекта мы должны самостоятельно мержить его оставшуюся (не обновляемую) часть
```javascript
state = { name: 'alex', surName: 'bolduin' };

// class component - ok. можем частично обновить стейт
this.setStata({ name: 'Boris' }); // { name: 'Boris', surName: 'bolduin' }

// function component - bad - не можем частично обновить стейт
setStata({ name: 'Boris' }); // { name: 'Boris' }

// function component - ok - обязаны передать полный стейт при обновлении
setStata((prevState) => ({ ...prevState, name: 'Boris' })); // { name: 'Boris', surName: 'bolduin' }
```
- useEffect - альтернатива методам жизненного цикла классового компонента.
  - функция ПОДПИСКИ (тело): срабатывает **ПОСЛЕ** любого рендера (как после обновления, так и после первого маунтинга) если нет массива зависимостей. Если массив есть - **ПОСЛЕ** каждого изменения любой зависимости из этого массива.
  - функция ОТПИСКИ (возвращаемая): срабатывает **ПЕРЕД** любым перерендером (в т.ч. перед удаление) - если нет массива зависимостей. Если массив есть - **ПЕРЕД** каждым перерендером, если этот перерендер произошел по причине изменения любой зависимости из этого массива.
  - массив зависимостей - ограничивает момент вызова. Отсутствие массива зависимостей = массив со всеми возможными зависимостями (т.е. будет выполняться на каждый рендер). Пустой массив = пустые зависимости (не от чего не зависим) - useEffect отработает один раз (функция подписки - на первый рендер, а функция отписки - перед удалением. Т.е. с помощью пустого массива мы можем эмулировать методы componentDidMount и componenWillUnmount)
```javascipt
useEffect(() => {
  // функция подписки (тело функции) - срабатывает ПОСЛЕ рендера
  const intervalId = setInterval(...)

  // функция отписки (возвращаемая функция) - срабатывает ПЕРЕД перерендером
  return () => {
    clearInterval(intervalId)
  }
  // массив завависимостей. Зависим от id - useEffect сработает на первый рендер и на каждое изменение id.
}, [ id ]);

useEffect(() => {
  // пустой массив завависимостей, значит функция подписки сработает только 1 раз на манутнге - аналог componentDidMount
  const intervalId = setInterval(...)

  // пустой массив зависимостей, значит функция подписки сработает только 1 раз перед анмаунтом - аналог componenWillUnmount
  return () => {
    clearInterval(intervalId)
  }
  //пустой массив зависимостей
}, [ ]);


useEffect(() => {
  // отсутствие массива зависимостей, значит функция подписки выполнится ПОСЛЕ КАЖДОГО рендера
  const intervalId = setInterval(...)

  // отсутствие массива зависимостей, значит функция подписки выполнится ПЕРЕД КАЖДЫМ перерендером
  return () => {
    clearInterval(intervalId)
  }
  // отсутствие массива зависимостей
});
```

## Второстепенные:
Функциональный компонент, в отличие от классов, не имеет инстанса, который живет между перерендерами, а значит не может сам по себе хранить значение между перерендерами. Следующие хуки помогают решить проблему **хранения значения между перерендерами**:
- useCallback - при каждом рендере в функциональном компоненте любая созданная функция хендлер это новая функция по ссылке. Используем useCallback если надо **сохранить ссылку на функцию** с предыдущего рендера. **!!! Любые зависимости функции должны быть в массиве зависимостей, иначе функция будет выполняться с с неактуальными значениями**
```javascipt
const Button = ({ onClick }) => {
  useEffect(() => {
    console.log('хочу выполняться если onClick изменился');
    console.log('но сразабатываю каждйы раз тк новый onClick по ссылке не равен предыдущему');
    fetch();
  }, [ onClick ]);

  return <button onClick />
}

const Parent = () => {
  // handleClick на каждый рендер создается новый и по ссылке не равен старому, а значит useEffect в компоненте Button срабатывает каждый раз
  const handleClick = () => {}

  // handleClickMemo из useCallback, по ссылке изменяется только когда изменится что-либо из массива зависимостей (в данном случае массив пустой, те никогда не изменится). А значит проблем useEffect компонента Button ушла, т.к. наш колбек между перерендерами по ссылке остается неизменным.
  const handleClickMemo = useCallback(() => {}, []);

  return <Button onClick={ handleClick } />
}
```
```javascipt
const Parent2 = () => {
  const [ variable ] = useState(0);

  const handleClickMemo = useCallback(() => {
  // наша функция используем переменную variable, т.е. зависит от нее
  console.log(variable);
  // !!! любые зависимости функции должны быть в массиве зависимостей, иначе функция будет исполняться с неактуальными значениями. Добавили переменную variable в массив.
}, [ variable ]);

return <Button onClick={ handleClick } />
}
```
- useMemo - любые вычисления (кроме тех что в useEffect) в функциональном компоненте выполняются на каждый рендер. Если эти вычисления ресурсоемкие, то с помощью useMemo мы можем **запомнить результат таких вычислений** с прошлого рендера и не пересчитывать их лишний раз
```javascipt
// функция veryComplexFn очень ресурсоемкая и отрабатывает 2 сек
const veryComplexFn = () => {}

const Component = () => {
  const [ state, setState ] = useState(0);

  // на каждый рендер вызывается veryComplexFn которая отрабатывает 2 сек, а значит наш компонент рендерится 2 сек. А с учетом что он может рендерится очень часто, то ui скорее всего просто повиснет.
  const result = () => veryComplexFn();

  // с помощью useMemo мы пересчитывает результат только при изменении массива зависимостей. В данном случае массив пустой, а значит мы взываем veryComplexFn только 1 раз на самом старте
  const resultMemo = useMemo(veryComplexFn, []);

  // для useMemo работает тоже правило, что и для остальных хуков - любые зависимости помещаем в массив зависимостей
  const resultMemo = useMemo(() => veryComplexFn(state), [ state ]);

  return <span>{ resultMemo }</span>
}
```
- useRef - возвращает рефу. В функциональных компонентах в ней также можно и нужно **хранить любые значения**, которые хотим сохранить между перерендерами, но изменение которых не должно приводить к новым перерендерам.

```javascipt
// Будем с помощью useRef считать кол-во перерендеров компонента. Т.к. изменения счетчика не должно приводить к новым перерендерам, то state нам не подходит.
const CompoenntWithRenderCounter = () => {
  const counter = useRef(0);

  // counter из useRef сохраняет свое значение между перерендарами и мы можем хранить и изменять любые данные в его свойстве current,
  counter.current++;
  
  return <span>Компонент отрендерелися {counter.current} раз</span>
}
```

# Контекст
Иногда приходится передавать пропсы глубоко через десятки компонентов, что будет крайне утомительным. Эта проблема называется property drill. Для ее решения используется контекст - альтернативный пропсам способ получения данных от родителя в обход промежуточных компонентов.
Т.е. если у вас есть компонент со стейтом и между ним и компонентом, которому этот стейт нужен лежит 2-3 промежуточных компонента - то ок, можно прокинуть данные как обычно пропсами через каждый промежуточный компонент. Но что если таких промежуточных компонентов не 2-3, а 20? 50? 100? Тогда чтобы не прокидывать данные через каждый компонент используем контекст и передаем данные в обход промежуточных компонентов.

[TODO] добавить пример конекста

# Важные правила при написании кода на React
- Если рассчитываем стейт на основе предыдущего, то используем синтаксис колбека для функции setState (в т.ч. для хуков)
- Не мутируем стейт и пропсы
- При паминге не забываем про уникальный пропс key

# Прочее
- **Фрагменты**- используем если нужно вернуть из компонента более одного корневого элемента
- Для оптимизации рендера можно использовать **shouldComponentUpdate / pureComponent / React.memo**
[TODO] пример React.memo
- **Рефы** нужны чтобы получить доступы к реальным DOM узлам (т.е. не к компонентам реакта, а к html который в браузере). Используются, например, для вызова фокуса у элемента, для создания неуправляемых компонентов или анимации. Создаем рефы с помощью React.createRef или хука useRef. Привязываем созданную рефу к нужному html элементу с помощью пропса ref.
- Для перенаправления рефов используем **React.forwardRef**. Перенаправлять рефы нужно, когда мы прокинули рефу не на html элемент, а на наш реакт компонент. Тогда этот компонент должен взять рефу и прокинуть ее дальше на html элемент.
```javascipt
const Component = () => {
  // создаем рефу, чтобы получить доступ реальному DOM узлу
  const ref = useRef<HTMLInputElement>(null);

  const focusHandler = () => {
    // нет другого способа вызвать focus у элемента, кроме как вызвать одноименный метод на DOM узле. Поэтому используем рефы, чтобы получить ссылку на этот DOM узел (реальный html из браузера)
    ref.current?.focus();
  }

  return (
    <div>
      // применяем рефу с помощью пропса ref, все работает т.к. мы применяем ее к html
      <input ref={ ref } />
      <button onClick={ focusHandler }>Focus input</button>
    </div>
  )
}
```
```javascript
// В коде выше мы прокидывали ref на html элемент.Но если input будет не html элементом, а react компонентом (оберткой), то возникнет проблема: ref - особый пропс и просто так к нему доступа нет. Чтобы получить к нему доступ и нужен forwarRef

// просто так доступа к пропсу ref не получить, тут ref всегда будет undefined
const BrokenInput = ({ ref }) => {
  console.log(ref); // undefined

  return <input ref={ ref } />
}

// Оборачиваем компонент в React.forwardRef, теперь у нас появился доступ к ref и мы можем прокинуть его в наивный html
const Input = React.forwardRef((props, ref) => {
  return <input ref={ ref } />
})

const Component = () => {
  const brokenRef = useRef<HTMLInputElement>(null);
  const ref = useRef<HTMLInputElement>(null);

  const focusBrokenHandler = () => {
    // не сработает т.к. в BrokenInput рефа уходит вникуда, не попадая на html элемент
    brokenRef.current?.focus();
  }

  const focusHandler = () => {
    // все ок, т.к. мы перенаправили с помощью React.forwardRef рефу на html элемент
    ref.current?.focus();
  }

  return (
    <div>
      <BrokenInput ref={ ref } />
      <Input ref={ ref } />
      <button onClick={ focusHandler }>Focus input</button>
      <button onClick={ focusBrokenHandler }>Focus input</button>
    </div>
  )
}
```
- ErrorBoyndary - компонент в котором использованы методы жизненного цикла static getDerivedStateFromError / componentDidCatch. Используется для отображения запасного ui, если в основном произошла ошибка в методе рендера. Аналог try / catch для компонентов.
