## Классы
  Мы можем применить наши типы и интерфейсы как к объектам, так и к классам. Применение типа к классу происходит с помощью ключевого слова implements

  ```typescript
  type UserType = { id: number; name: string }
  interface UserInterface { id: number; name: string }

  const userObject1: UserType = { id: 1, name: 'Alex' }
  const userObject2: UserInterface = { id: 1, name: 'Alex' }

  class User1 implements UserType {
    id = 1;
    name = 'Alex';
  }

  class User2 implements UserInterface {
    id = 1;
    name = 'Alex';
  }
  ```

  Методы и свойства классов могут иметь модификаторы доступа:
 - public - (применяется по умолчанию, если никакой модификаторы явно неприменен) - метод / свойство доступно самому классу, дочерним классам и всем инстансам
 - private - метод / свойство доступно только самому классу и НЕ доступно любым инстансам и дочерним классам
 - protected - метод / свойство доступно самому классу и дочерним классам, но НЕ доступно любым инстансам

  Кроме того, методы и свойства делятся на статические и динамические:
 - статические - существуют на классе и не имеют this
 - динамические - существуют на инстансе класса и имеют this

  Также свойства могут быть с модификатором readonly

  ```typescript
  class Parent {
    readonly id = 1;

    // public по умолчанию
    method1 () { }

    public method2 () { }

    private method3 () { }

    protected method4 () { }

    // public по умолчанию
    static method5 () { }

    public static method6 () { }

    private static method7 () { }

    protected static method8 () { }
  }

  class Child extends Parent {
    method () {
      this.method1(); // ok, т.к. public
      this.method2(); // ok, т.к. public
      this.method3(); // fail, т.к. private
      this.method4(); // ok, т.к. protected

      Child.method5(); // ok, т.к. public
      Child.method6(); // ok, т.к. public
      Child.method7(); // fail, т.к. private
      Child.method8(); // ok, т.к. protected

      Parent.method5(); // ok, т.к. public
      Parent.method6(); // ok, т.к. public
      Parent.method7(); // fail, т.к. private
      Parent.method8(); // ok, т.к. protected
    }
  }
  ```

  Классы можно использовать и как тип – это единственное исключение в ts, которое одновременно может быть и js сущностью и ts типом.

  ```typescript
  class Car {
    label: string = '';

    run (): void {

    }
  }

  // используем класс для типизации параметра функции
  const runTransport = (transport: Car) => {
    transport.run();
  }
  ```

## Utility types
[Полный список в документации](https://www.typescriptlang.org/docs/handbook/utility-types.html)

Наиболее часто используемые:
-  Awaited - получить значения возвращаемое **типизированным** промисом
-  Partial - новый объект на основе существующего, но все поля опциональны
-  Required -  новый объект на основе существующего, но все поля обязательны
-  Readonly -  новый объект на основе существующего, но все поля ридонли
-  Record - способ создания типа объекта, альтернатива [индексной сигнатуре](https://github.com/fetchMachine/tms-fe84/blob/master/01-ts_intro.md#%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D0%B3%D0%BD%D0%B0%D1%82%D1%83%D1%80%D1%8B)
-  Pick - новый объект на основе существующего, выбрав только указанные поля исходного объекта
-  Omit - новый объект на основе существующего, выбрав все поля исходного объекта, кроме указанных
-  NonNullabl - если тип является [объеденением](https://github.com/fetchMachine/tms-fe84/blob/master/01-ts_intro.md#%D0%BE%D0%B1%D1%8A%D0%B5%D0%B4%D0%B8%D0%BD%D1%91%D0%BD%D0%BD%D1%8B%D0%B5-%D0%B8-%D0%BF%D0%B5%D1%80%D0%B5%D1%81%D0%B5%D0%BA%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%D1%81%D1%8F-%D1%82%D0%B8%D0%BF%D1%8B) других и содержит null или undefined, то удаляет null и undefined из объеденения
-  Parameters - возвращает тип параметров функции в виде кортежа. Передавать надо не саму функции, а ее тип. Например ``Parameters<typeof myFunction>``
-  ReturnType - возвращает тип возвращаемого функцией значения. Передавать надо не саму функции, а ее тип. Например ``ReturnType<typeof myFunction>``


## Дженерики
Дженерик - обобщенный тип, конкретный тип будет подставлен в момент использования дженерика. Используется вместо any, когда тип заранее неизвестен, но будет извествен в момент применения дженерика (например в момент "вызова" функции типизированный как дженерик). Тогда с помощью дженерика в момент применения мы можем получить конкретный тип и использовать его дальше, чтобы сохранить типизацию приложения (тогда как any сломает типизацию)

  ```typescript
  // Тут нам заранее неизвестно с каким типом будет вызвана наша функция,
  // но при этом мы не хотим использовать any т.к. это поломает типизацию (возвращаемое значение станет массив из any).
  // Поэтому используем дженерик.
  const asArray = <T>(value: T): T[] => [ value ];
  // В момент "вызова" функции мы передаем конкретные значения у которых есть конкретный тип (например тут двойка, т.е. тип number).
  // Соответственно для этого конкретного вызова дженерик "T" будет типа number,
  // а значит возвращаемое значение затипизированное как "T[]" также будет number[]
  const newValue = asArray(2);

  // О дженерике также можно думать, как о функции: мы получаем какие-то входящие параметры типы и возвращаем новый тип.
  // Например, напишем дженерик, который принимает любой тип и добавляет к нему тип undefined
  type WithUndefined<T> = T | undefined;
  type NumberOrUndefined = WithUndefined<number> // number | undefined

  /*
    Более сложный пример. Функция получения поля объекта по ключу.
    Мы также заранее не знаем какой объект придет, поэтому использует дженерик для его типизации.
    Но в отличие от примера asArray выше, где нам все равно какой тип к нам придет, тут мы хотим ограничить входящий тип,
    чтобы это был объектом. Для этого применяется ключевое слово extends.
    Таким образом наш дженерик тип "O" может быть любым объектом,
    а что это будет за конкретный объект мы узнаем в момент "вызова" функции.

    Кроме того, мы используем дженерик для типизации второго параметра - ключа объекта.
    Т.к. если мы просто воспользуемся типом "key: keyof O",
    то получим тип вида ЛЮБОЙ ключ нашего объекта, а мы хотим получить КОНКРЕТНЫЙ ключ указанный в момент вызова.
    Для получения конкретных типов в момент вызова мы, как и раньше, используем дженерик.
  */
  const getByKey = <O extends Record<string, any>, K extends keyof O>(obj: O, key: K): O[K] => obj[key];
  
  // благодаря ограничению через ключевое слово extends мы не сможем прокинуть первым параметром что-то отличное от объекта,
  // а вторым что-то отличное от ключа этого объекта
  const id = getByKey([{ name: 'Alex', id: 2 }], 'id'); // fail, первые параметр на объект
  const age = getByKey({ name: 'Alex', id: 2 }, 'age'); // fail, второй параметр не ключ объекта, т.к. поля age не существует
  const id = getByKey({ name: 'Alex', id: 2 }, 'id'); // ok
  ```
