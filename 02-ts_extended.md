## Классы

## Utility types
[Полный список в документации](https://www.typescriptlang.org/docs/handbook/utility-types.html)

Наиболее часто используемые:
-  Awaited - получить значения возвращаемое **типизированным** промисом
-  Partial - новый объект на основе существующего, но все поля опциональны
-  Required -  новый объект на основе существующего, но все поля обязательны
-  Readonly -  новый объект на основе существующего, но все поля ридонли
-  Record - способ создания типа объекта, альтернатива [индексной сигнатуре](https://github.com/fetchMachine/tms-fe84/blob/master/01-ts_intro.md#%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D0%B3%D0%BD%D0%B0%D1%82%D1%83%D1%80%D1%8B)
-  Pick - новый объект на основе существующего, выбрав только указанные поля исходного объекта
-  Omit - новый объект на основе существующего, выбрав все поля исходного объекта, кроме указанных
-  NonNullabl - если тип является [объеденением](https://github.com/fetchMachine/tms-fe84/blob/master/01-ts_intro.md#%D0%BE%D0%B1%D1%8A%D0%B5%D0%B4%D0%B8%D0%BD%D1%91%D0%BD%D0%BD%D1%8B%D0%B5-%D0%B8-%D0%BF%D0%B5%D1%80%D0%B5%D1%81%D0%B5%D0%BA%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%D1%81%D1%8F-%D1%82%D0%B8%D0%BF%D1%8B) других и содержит null или undefined, то удаляет null и undefined из объеденения
-  Parameters - возвращает тип параметров функции в ввиде кортежа. Передавать надо не саму функции, а ее тип. Например Parameters<typeof myFunction>
-  ReturnType - возвращает тип возвращаемого функцией значения. Передавать надо не саму функции, а ее тип. Например Parameters<typeof myFunction>


## Дженерики
Дженерики - общие типы. Используются когда нам заранее неизвестен тип.
  
```typescript
  // тут нам заранее неизвестно с каким типов будет вызвана наша функция, но при этом мы не можем использовать any для типизации т.к. это поломает типизацию (возвращаемое значение станет массив из any)
  const asArray = <T>(value: T): T[] => [ value ];
  const newValue = asArray(2); // передав числов мы ожидаем в newValue получить тип массива чисел, any поломает типизацию. Поэтому используем дженерик.
  
  // Функция получения поля объекта по ключу. Мы заранее не знаем какой объект придет, поэтому использует дженерик для типизации объекта. Кроме того мы используем дженерик 
  const getByKey = <O extends Record<string, any>, K extends keyof O>(obj: O, key: K): O[K] => obj[key];
  
  const addToObject = <O extends Record<string, any>, K extends string, V>(obj: O, key: K, value: V): O & { [key in K]: V } => {
  return {
    ...obj,
    [key]: value,
  };
}
```
