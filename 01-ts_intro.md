  ## ОКРУЖЕНИЕ
  - [Playground](https://www.typescriptlang.org/play)
  - typescript / ts-node / nodemon
  
  ## НАСТРОЙКА ЛОКАЛЬНОГО ОКРУЖЕНИЯ
  ```bash
  npm init -y
  git init -q
  npm i typescript ts-node nodemon
  npx tsc --init
  ```
  
  В файле ``tsconfig.json`` расскоментировать все в блоке ``/* Type Checking */``
  Создать файл для работы ``index.ts``.
  
  Скомпилировать ts файл в js
  ```bash
  npx tsc
  ```
  
  Запустить nodemon чтобы проект выполнялся на каждое редактирование файла
  ```bash
  npx nodemon index.ts
  ```
  
  При желании можно добавить эти комманды в скрипты проекта (файл ``package.json``, поле ``"scripts"``)
  ```json
  "scripts": {
    "dev": "nodemon index.ts",
    "build": "tsc"
  }
  ```

  ## TYPESCRIPT ЭТО
  - надмножество JS
  - предоставляет статическую проверку типов, автокомплит, возможность компилировать код в разные версии JS
  - структурная типизация, требует минимального наличие свойств и их корректной типизации
  - требует конфигурации
  - автоматически выводит типы
  - **СУЩЕСВУЕТ ТОЛЬКО НА ЭТАПЕ КОМПИЛЯЦИИ**

  ## Правила хорошего тона
  - Называем типы / интерфейсы с большой буквы
  - Не используем тип any

  ## Базовые типы (number, string, boolean)
  ```typescript
  let myNumber: number;
  let myString: string;
  let myBool: boolean;
  let myNull: null;
  let myUndefined: undefined

  type NumberType = number;
  type StringType = string;
  ```

  ## Пользовательские типы
  Если какой-то тип используется в нескольких местах, то вместо его дублирования мы можем создать свой пользовательский тип и его переиспользовать. Например, на проекте id может быть как числом так и строкой:

  ```typescript
  // Создаем свой тип через ключевое слово type
  type Id = number | string;

  // используем его
  let id: Id;
  ```

  ## Массивы, кортежи, перечисления
  ```typescript
  // массивы
  const stringArr: string[] = [];
  const numberArr: number[] = [];

  // точно также можем создавать свои отдельные типы
  type NumberArray = number[];

  // c помощью ReadonlyArray можно создать массив, который нельзя изменять
  const arr: ReadonlyArray<string> = ['s'];
  arr.push('f') // error, т.к. массив неизменяемый
  arr[0] = 'f' // error, т.к. массив неизменяемый
  arr[1] = 'f' // error, т.к. массив неизменяемый

  // кортеж - массив конкретной структуры, т.е. имеет конкретную длину и конкретные типы на каждой позиции
  const userData: [string, number] = ['alex', 45];

  // точно также можем создавать свои отдельные типы
  type myTuple = [string, boolean, string[]];

  // перечисление - аналог объекта в JS, если обычные типы удаляются при компиляции ts в js, то перечисления трансформируются в js объекты и остаются в рантайме. Используем их как коллекцию констант, например перечисление всех возможных пользовательских ролей на сайте:
  enum USER_ROLES {
    ADMIN ='admin',
    GUEST ='guest',
  }
  ```

  ## Объекты
  ```typescript
  type User = {
    id: number, // обязательное свойство типа число, которое можно мутировать
    name?: string, // Не обязательное свойство типа число, которое можно мутировать
    readonly age: number, // обязательное свойство типа число, которое нельзя мутировать,
    readonly isSingle?: boolean, // Не обязательное свойство типа число, которое нельзя мутировать
    readonly family: User[]; // можно создавать сложные вложенные структуры, в т.ч. рекурсивные
  };

  const user: User = { id: 1, age: 2, isSingle: true, family: [] }; // ok, т.к. name не обязательное свойство
  user.id = 2 // ok, т.к. id можно мутировать
  user.isSingle = false // error т.к. isSingle нельзя мутировать
  ```

  ## Интерфейсы (свойства, расширения)
  Интерфейсы являются почти полной альтернативой типам (ключевому слову type). С той разницей что с помощью type мы можем создать любой тип, а с помощью интерфейсов только тип объекта. Более подробно про нюансы отличия можно прочитать здесь [type vs interface](https://www.typescriptlang.org/play/typescript/language-extensions/types-vs-interfaces.ts.html)

  ```typescript
  // Пример типа User (см выше в разделе "Объекты"), переписанный на интерфейс
  interface User {
    id: number, // обязательное свойство типа число, которое можно мутировать
    name?: string, // Не обязательное свойство типа число, которое можно мутировать
    readonly age: number, // обязательное свойство типа число, которое нельзя мутировать,
    readonly isSingle?: boolean, // Не обязательное свойство типа число, которое нельзя мутировать
    readonly family: User[]; // можно создавать сложные вложенные структуры, в т.ч. рекурсивные
  };
  ```

  Интерфейсы можно наследовать, создавая тем самым новые на базе уже имеющихся. Для этого используется ключевое слово extends

  ```typescript
  intreface SimpleUser {
    id: number;
    name: string;
  }

  interface VipUser extends SimpleUser {
    vipStatus: string;
  }

  const user: VipUser = { vipStatus: 'gold' }; // error, т.к. не хватает унаследованных свойств id и name
  ```

  ### Индексные сигнатуры
  Применяются, когда мы не хотим типизировать ключи объекта, но хотим указать тип значений. Например, создадим объект с любыми ключами, но все значения обязательно или строка, или число:

  ```typescript
  // интерфейс
  interface StringOrNumberCollection  {
    [index: number]: string | number;
  }

  // тип
  type StringOrNumberCollection  = { [key in string]: string |number };
  ```

  ## Объединённые и пересекающиеся типы
  Пересечение типов. **аналог наследования** у интерфейсов. Результат пересечения - новый тип который должен удовлетворять **ВСЕМ** пересекающимся типам. Другими словами, это логическое **И**.

  Объединение типов. Результат объединения - новый тип которой должен удовлетворять хотя бы **ОДНОМУ** из пересекающихся типом. Другими словами, это логическое **ИЛИ**.

  ```typescript
  type User = { id: number; name: string };
  type Order = { cost: number };

  // пересечение
  type UserAndrderIntersection = User & Order;

  // объединение
  type UserOrOrderUnion = User | Order;

  let intersection: UserAndrderIntersection;
  intersection = { id: 2, name: '' } // error, т.к. не удовлетворяет Order (не хватает cost)
  intersection = { cost: 55 } // error, т.к. не удовлетворяет User (не хватает id и name)
  intersection = { id: 2, name: '', cost: 55 } // ok, т.к. удовлетворяет **ВСЕМ** типам: И типу User и типу Order

  let union: UserOrOrderUnion;
  union = { id: 2, name: '' } // ок, т.к. удовлетворяет User
  union = { cost: 55 } //  ок, т.к. удовлетворяет Order
  union = { id: 2, name: '', cost: 55 } // eror, т.к. не удовлетворяет **НИ ОДНОМУ**: ни User (лишнее свойство cost) ни Order (лишние свойства id и name)

  // пример с массивами
  const StringOrNumberArray: (string | number)[] = [];
  ```

  ## Литеральные типы
  Типами могут выступать не только абстрактные числа, строки и тд, но и конкретные значения, например
  ```typescript
  type FiveOrTen = 5 | 10;
  type UserRole = 'admin' | 'guest'
  type True = true;
  ```

  Можно использовать шаблонные строки для конструирования более сложных составных типов (когда надо вместе применить **И** абстрактные числа, строки **И** конкретные их значения). Например, мы хотим создать тип для CSS размерности (например 8px), это должна быть строка, которая начинается с **ЛЮБОГО** числа и заканчивается **КОНКРЕТНОЙ** строй 'px';
  ``type PixelSize = `${number}px```

  ```typescript
  let size: PixelSize;
  size = '5px' // ok
  size = 'epx' // eror, т.к. начинается не с числа
  size = '4pz' // error, т.к. не заканчивается на 'px'
  ```

  // Более сложные пример, когда мы используем любое числе и несколько конкретных строк (другими словами у нас объединение таких строка)
  type CssSize = `${number}${'px' | 'rem'}`
  ```

  ## Функции (аргументы, контекст, перегрузка функции)
  ```typescript
  const sum = (x: number, y: number): number => x + y;

  function pow (x: number, y: number): number {
    return x**y;
  };

  // this типизируется всегда первым параметром
  functionWithThis(this: number, multiplicator: number): number {
    return this + multiplicator;
  }
  ```

  ## Защитники типов и различение типов
  Когда на у нас есть тип как объединение других, а нам надо выполнить работу специфическую только для одного из них, нам нужно определить с каким типом именно мы работаем.

  ```typescript
  // Например, тут на вход приходит или строка или число, а метод toLowerCase есть только у строки. Поэтому мы должны определить, что именно за тип к нам пришел прежде чем работать

  // тут value имеет тип число или строка
  const toLowerCase = (value: number | string): string => {
    if (typeof value === 'string') {
      // после это проверки ts понимает что value имеет тип строка
      return value.toLowerCase();
    }

    // т.к. в рамках предыдущего if мы делаем return, то ts понимает, что тут остался только тип число
    return String(value);
  }
  ```

  Такие проверки позволяют тайпскрипту сузить тип, чтобы он понимал с каким именно типом он работает. И разумеет такие проверки нужны нам, что код не упал при выполнении, когда мы попытаемся вызвать toLowerCase у пришедшего числа.

  Есть несколько стратегий как различить типы
  - typeof / instanceof (пример выше)
  - Проверить наличие какого-то уникального свойства (см ниже)
  - Проверить значение какого-то общего для всех свойства, если каждый тип имеет свое уникальное значение (см ниже)

  ```typescript
  interface Shape {
      type: string;
  }

  interface Square extends Shape {
      type: 'square';
      getSide: () => number;
  }

  interface Circle {
      type: 'circle';
      getRadius: () => number;
  }

  const toLowerCase = (value: Circle | Square): number => {
    // проверяем наличие уникального свойства
    if ('getRadius' in value) {
      return value.getRadius();
    }

    return value.getSide()
  }

  const toLowerCase = (value: Circle | Square): number => {
    // проверка общего для всех свойства type, которое при это имеет уникальное значение для каждого из типов
    if (value.type === 'circle') {
      return value.getRadius();
    }

    return value.getSide()
  }
  ```

  ## Преобразования типов
  Возможно сужать вручную типы - из более общих делать более конкретные. Для этого используется оператор as:

  ```typescript
  // value типа число или строка
  const f = (value: number | string): string => {
    // сузили до просто строки
    return (value as string).toLowerCase();
  }
  ```

  **ВАЖНО** такое сужение работает только на уровне типов, т.е. когда ts скомпилируется в js и все типы удаляться, то никакого приведения числа к строке не произойдет, и если в нашу функцию придет число, то код сломается, т.к. у числа нет метода toLowerCase.
  Поэтому применять с осторожностью. Например, когда вы сделали проверку на тип, но тайпгвард не сработал и ts не может сам корректно вывести тип.

  ## Другие простейшие типы (Any, Unknown, Never, Void)
  any - любой тип, потенциально ломает типизацию на проекте, **НЕ ИСПОЛЬЗУЕМ**
  unknown - безопасный аналог any, также любой тип, но ts принуждает делать проверку типов перед операциями над unknown
  void - отсутсвие какого-либо типа, например, тип возвращаемого значения функции которая ничего не возвращает
  never - невозможный тип, тип, который не может существовать, возникает как ошибка операций над типами. Например, при попытке создать тип, одновременно отвечающий требованиям строки и числа.
  ```typescript
  type StringAndNumber = string & number; // never
  ```
